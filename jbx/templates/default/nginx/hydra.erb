# Optimize loading process
init_by_lua_block {
    -- Flatten table of arguments into a 2d map
    local function safe_url_args(args)
        if type(args) == "table" then
            for k,v in pairs(args) do
                -- Grab the last value from any table
                if type(v) == "table" then
                    args[k] = tostring(safe_url_args(v)[#v] or nil)
                -- Force to empty string if it's boolean
                elseif type(v) ~= "string" then
                    args[k] = ""
                end
            end
        end
        
        return args
    end
    
    -- Get a delimited list of table keys as a string
    local function table_keys(table, sep)
        local n     = 0
        local str   = ""
        sep         = sep or "!"
        
        for k,v in pairs(table) do
            str = str .. (str:len() > 0 and sep or "") .. k
        end
        
        return str
    end
    
    -- Turn POST to GET
    local function post_to_get()
        if ngx.var.request_method == "POST" then
            ngx.req.read_body()
            
            -- Get both GET and POST args
            local args      = safe_url_args(ngx.req.get_uri_args() or {})
            local post_args = safe_url_args(ngx.req.get_post_args() or {})
            local post_count=0
            
            -- Merge POST into GET, but GET takes precedence
            for k,v in pairs(post_args) do
                args[k]     = args[k] or v
                post_count  = post_count + 1
            end
            
            -- Record the fact that this conversion took place
            if post_count > 0 then
                args["post_to_get"] = table_keys(post_args) or ""
            end
            
            -- Place args back
            ngx.req.set_uri_args(args)
            
            -- Discard request body - only GET to upstream!
            ngx.req.set_body_data("")
        end
    end
    
    _G.safe_url_args    = safe_url_args
    _G.table_keys       = table_keys
    _G.post_to_get      = post_to_get
}

server {
    listen 80 default_server reuseport;
    listen [::]:80 default_server reuseport;
    
    server_name                     ~^(?<subdomain>)(?<domain>[^\.]+(\.:)[^\.:]+)$
                                    ~^(?<subdomain>.*?(\.|:))(?<domain>[^\.]+(\.|:)[^\.:]+)$
                                    ~^(?<subdomain>)(?<domain>.*)$;
    
    merge_slashes                   off;
    access_log                      off;
    
    # Default upstream server
    set                             $upstream hydra-hp;
    
    # Whether or not request is encrypted
    set                             $encrypted_uri "";
    set                             $original_args "";
    set                             $decrypted_args "";
    
    # Fix X-Forwarded-For to strip out the proxy addresses
    set_by_lua_block $real_x_forwarded_for { 
        local ip            = ngx.var.remote_addr
        local x_forwarded   = ngx.var.http_x_forwarded_for or ""
        
        -- Find the LAST occurrence of the true IP inside the x-forwarded header
        local regex         = "^(.*)" .. ip:gsub("%W","%%%0") .. ".-$"
        local x_forwarded   = x_forwarded:gsub(regex, "%1"):gsub(",?%s*$", "") or ""
        
        -- No x-forwarded-for header, nothing to do
        if x_forwarded:len() == 0 then
            return ip
        end
        
        -- Set real_x_forwarded_for header
        return x_forwarded .. "," .. ip
    }
    
    # Ensure domain is set
    set_by_lua_block $domain {
        -- Ensure the domain ends with an alpha string (ruling out ipv4 or v6 addresses), and that it's not a regex
        local valid_domain  = ngx.var.domain:match("%p%a+$") and ngx.var.domain:match("?") == nil
        
        -- Modify domain & subdomain to acceptable values if they're direct IPs
        ngx.var.subdomain   = valid_domain and ngx.var.subdomain or "www."
        return valid_domain and ngx.var.domain or "mediaclicktrker.com"
    }
    
    # Show server host name as header
    more_set_headers                'Server: Hydra';
    more_set_headers                'X-Content-Type-Options: nosniff';
    more_set_headers                'X-XSS-Protection: 0';
    more_set_headers                'Referrer-Policy: never, no-referrer';
    more_set_headers                'Content-Security-Policy: upgrade-insecure-requests';
    more_set_headers                'Cache-Control: no-cache, no-store, must-revalidate';
    more_set_headers                'Pragma: no-cache';
    expires                         epoch;
    
    # Debugging headers
    more_set_headers                "X-Backend-Connect-Time: $upstream_connect_time";
    more_set_headers                "X-Backend-Response-Time: $upstream_header_time";
    more_set_headers                "X-Backend-Status: $upstream_status";
    more_set_headers                "X-Backend-Uri: $uri";
    more_set_headers                "X-Backend-Args: $args";
    
    location = /favicon.ico { 
        return                      204;
    }
    
    location = /robots.txt {
        add_header                  Content-Type text/plain;
        return                      200 "User-agent: *\nDisallow: /\n";
    }
    
    location = /hsts {
        add_header                  Content-Type application/javascript;
        return                      204;
    }
    
    location = / {
        return                      204;
    }
    
    # Explicity define this route or it gets picked up as an encrypted link
    location = /thisthingisnotathing {
        try_files                   @proxy @proxy;
    }
    
    # HP Status Endpoint
    location = /status.php {
        set                         $upstream hp;
        try_files                   @proxy @proxy;
    }
    
    location = /status {
        allow                       127.0.0.1;
        deny                        all;
        
        check_status;
    }
    
    location = /nginx {
        allow                       127.0.0.1;
        deny                        all;
        
        stub_status                 on;
    }
    
    location ~ /fpm(-ping)?$ {
        allow                       127.0.0.1;
        deny                        all;
        
        fastcgi_pass                hydra;
        fastcgi_param               SCRIPT_FILENAME $uri;
        include                     fastcgi_params;
    }
    
    location ^~ /v1/ {
        allow                       10.0.0.0/8;
        allow                       127.0.0.1/32;
        allow                       172.16.0.0/12;
        allow                       192.168.0.0/16;
        allow                       fd00::/8;
        deny                        all;
        
        proxy_pass                  http://127.0.0.1:8500;
    }
    
    # Rotator routes - HP does not know how to handle these
    location ~* ^/(campaign|affiliate|script)/ {
        set                         $upstream hydra;
        
        try_files                   @proxy @proxy;
    }
    
    # Catch errors caused by stripping ~ characters from special-base64 encoded urls
    rewrite "^(/(?:[A-Za-z0-9-_]{4}){4,}(?:[A-Za-z0-9-_]{2}))(/.*)?$"  $1~~$2  last;
    rewrite "^(/(?:[A-Za-z0-9-_]{4}){4,}(?:[A-Za-z0-9-_]{3}))(/.*)?$"  $1~$2   last;
    rewrite "^(/(?:[A-Za-z0-9-_]{4}){4,}(?:[A-Za-z0-9-_]{2}~))(/.*)?$" $1~$2   last;
    
    # Decrypt redirect URLs
    location ~ "^/([A-Za-z0-9-_]{4}){4,}([A-Za-z0-9-_]{2}~~|[A-Za-z0-9-_]{3}~)?~*(/|$)" {
        
        # Keep the original encrypted URL in case we need to 3xx - we dont want to leak the real one
        set $encrypted_uri $uri;
        set $original_args $args;
        
        rewrite_by_lua_block {
            post_to_get()
            
            local aes       = require "resty.aes"
            local str       = require "resty.string"
            local cjson     = require "cjson.safe"
            
            local rd        = "/rd/r.php"
            local uri       = ngx.var.uri
            local args      = safe_url_args(ngx.req.get_uri_args() or {})
            
            -- Split the request uri /<encrypted_string>[/<c1>/<c2>/<c3>[/...]]
            local vars      = {}
            local index     = 2
            local len       = uri:len() + 1
            
            while index < len do
                local next      = uri:find("/", index) or len
                vars[#vars + 1] = uri:sub(index, next - 1)
                index           = next + 1
            end
            
            -- Encryption key, md5 of HitPaths key
            local encryption_key = "f3a51b6c2d80757485b82fed8b7e69de"
            
            -- HitPath's specified IV a base64 encoded binary value
            local iv = {iv = ngx.decode_base64("/6X1qWqcchVbzFy7EEQQ8Q==")}
            
            -- Encryption service
            local aes_256_cbc = aes:new(encryption_key, nil, aes.cipher(256, "cbc"), iv)
            
            -- Swap unsafe URL characters for their correct version, and decode
            uri = vars[1]:gsub(".", {["-"] = "+", ["_"] = "/", ["~"] = "="}) or "";
            uri = ngx.decode_base64(uri) or ""
            
            -- Decrypt and decode the JSON payload if possible
            local decrypted = aes_256_cbc:decrypt(uri) or "{}"
            local decoded   = cjson.decode(decrypted) or {}
            
            -- save decoded args for later user
            ngx.var.decrypted_args = ngx.encode_args(decoded)
            
            -- Merge encrypted args into passed ones
            local mapping = { ["agentid"] = "pub", ["progid"] = "sid", ["ctype"] = nil, ["cid"] = nil, ["lpid"] = nil }
            for k,v in pairs(decoded) do
                -- HP encrypted links include hardcoded values of 0 for ctype, cid, lpid
                --  We dont use ctype in our links internally, so if ctype is encrypted in the URL it should have originated on HP
                if decoded["ctype"] == nil or (v ~= "0" and v ~= 0) then
                    args[mapping[k] or k] = args[mapping[k] or k] or v 
                end
            end
            
            -- Add c vars
            args["c1"]    = args["c1"] or vars[2]
            args["c2"]    = args["c2"] or vars[3]
            args["c3"]    = args["c3"] or vars[4]
            
            -- If _url is encrypted as a param, restore it as the path & delete from args
            if args["_url"] ~= nil then
                rd              = args["_url"]
                args["_url"]    = nil
            end
            
            -- Update request to _url or /rd/r.php (default) format and rewrite
            ngx.req.set_uri_args(args)
            ngx.req.set_uri(rd, true)
        }
    }
    
    # Salvage poorly configured requests
    location ~* ^(/rd/[^/]+)/ {
        set                         $subdomain "re.";
        rewrite                     ^(/rd/[^/]+)(.+) $1?path=$2;
    }
    
    # Rate limit redirects to 1 per ip, 1 per 5sec
    location ~* ^/rd/(r|o) {
        rewrite_by_lua_block {
            post_to_get()
            
            -- Dont allow unencrypted routes on non-hp links
            if ngx.var.domain:match("mediaclick") == nil and ngx.var.encrypted_uri:len() == 0 then
                --ngx.exec("@redirect_encrypted_only")
            end
            
            -- Create a MD5 hash of affiliate vars
            local args          = safe_url_args(ngx.req.get_uri_args() or {})
            args["md5"]         = ngx.md5(
                (args["pub"] or "") ..
                (args["progid"] or "") ..
                (args["c1"] or "") .. 
                (args["c2"] or "") .. 
                (args["c3"] or "") .. 
                (args["bps"] or "") ..
                (args["step"] or "")
            )
            
            ngx.req.set_uri_args(args)
        }
        
        error_page                  404 =403 @redirect_encrypted_only;
        error_page                  503 @redirect_exponential_backoff;
        
        # Only allow 1 concurrent request
        limit_conn                  conn_limit_per_ip 1;
        limit_conn_status           503;
        
        # 5 seconds between duplicate requests
        limit_req                   zone=force_cookie_reuse nodelay;
        limit_req_status            503;
        
        # Continue normal processing
        try_files                   @proxy @proxy;
    }
    
    # Restrict simultaneous pixel fires
    location ~* ^/rd/(px|ipx|hs|csp|sml) {
        rewrite_by_lua_block {
            post_to_get()
            
            -- Dont allow unencrypted routes on non-hp links
            if ngx.var.domain:match("mediaclick") == nil and ngx.var.encrypted_uri:len() == 0 then
                --ngx.exec("@redirect_encrypted_only")
            end
        }
        
        error_page                  404 =403 @redirect_encrypted_only;
        error_page                  503 @redirect_exponential_backoff;
        
        # Only allow 1 concurrent request
        limit_conn                  conn_limit_per_ip 1;
        limit_conn_status           503;
        
        # Continue normal processing
        try_files                   @proxy @proxy;
    }
    
    # Audit endpoint for analyzing dead requests
    location ~* ^/rd/audit {
        content_by_lua_block {
            ngx.header['Content-Type'] = "image/gif"
            ngx.say(ngx.decode_base64("R0lGODdhAQABAIAAAPxqbAAAACwAAAAAAQABAAACAkQBADs="))
            ngx.exit(200)
        }
    }
    
    # All other Redirect / Pixel types have no guard
    location ~* ^/rd/ {
        try_files                   @proxy @proxy;
    }
    
    # Error reporting when unencrypted redirect urls are detected
    location @redirect_encrypted_only {
        add_header                  Content-Type text/plain;
        return                      403 "Sorry, this server only accepts encrypted URLs.\nPlease find updated links.\n";
    }
    
    # 302 base rate limiting to force the re-use of cookies under race conditions
    location @redirect_exponential_backoff {
        content_by_lua_block {
            local uri   = ngx.var.uri
            local args  = safe_url_args(ngx.req.get_uri_args() or {})
            
            -- Remove md5 arg
            args["md5"]            = nil
            args["post_to_get"]    = nil
            
            -- Default back to the original encrypted URL & query string if one exists
            if ngx.var.encrypted_uri ~= nil and ngx.var.encrypted_uri:len() > 0 then
                uri     = ngx.var.encrypted_uri
                args    = safe_url_args(ngx.decode_args(ngx.var.original_args) or {})
                ngx.req.set_uri_args(args)
            end
            
            -- function to validate whether a parameter is a natural number
            local not_natural = function(n)
                return (n == nil) or (math.floor(n) ~= n) or (n < 0)
            end
            
            -- validate initial value
            if args.retries == nil or not_natural(tonumber(args.retries)) then
                args.retries = 0
            end
            
            local retries = tonumber(args.retries)
            args.retries  = retries + 1
            
            -- don't allow endless retries
            if args.retries > 5 then
                ngx.status = 409
                ngx.say("Sorry, you've exceeded the simultaneous request limit.\nPlease try again shortly.\n")
                ngx.exit(409)
            end
            
            -- exponential backoff & then try again
            ngx.sleep((retries * (retries + 1)) / 2)
            ngx.status = 302
            ngx.redirect(uri .. "?" .. ngx.encode_args(args), 302)
            ngx.exit(302)
        }
    }
    
    # Catch all
    location / {
        try_files                   @proxy @proxy;
    }
    
    location @proxy {
        if ($block_ua) {
            return 444;
        }
        
        # A few final tasks before proxying
        rewrite_by_lua_block {
            post_to_get()
            
            local args              = safe_url_args(ngx.req.get_uri_args() or {})
            
            -- Block potentially harmful retry/redirect loops
            if (args.retries ~= nil and tonumber(args.retries) > 5) or
                    (args.redirects ~= nil and tonumber(args.redirects) > 3) then
                ngx.status = 409
                ngx.say("Sorry, it seems like you're stuck in a redirect loop.\nPlease try again shortly.\n")
                ngx.exit(409)
            end
            
            -- Further processing on encrypted/decrypted arguments for safety
            local encrypted         = ngx.decode_args(ngx.var.decrypted_args or "") or {}
            local restricted        = { "_url", "md5", "rhid", "rsid", "origin", "referer", "cookie", "accept" }
            
            -- If rhid is set it's not safe to forward on to HP or we could get duplicates
            if ngx.var.upstream:match("hp") ~= nil and (args["rhid"] ~= nil or encrypted["rhid"] ~= nil) then
                ngx.var.upstream = "hydra"
            end
            
            -- Force restricted arguments back to their value from the encrypted URL, or delete them
            for k,v in pairs(restricted) do
                if args[v] ~= nil then
                    args[v] = encrypted[v] or nil
                end
            end
            
            -- persist the safe arguments back to args
            ngx.req.set_uri_args(args)
        }
        
        # Connection limits to prevent abuse
        limit_conn                  conn_limit_per_ip 25;
        limit_conn                  conn_limit_per_upstream 1000;
        
        proxy_set_header            X-Real-IP $remote_addr;
        proxy_set_header            X-Forwarded-For $real_x_forwarded_for;
        proxy_set_header            X-Forwarded-Proto $real_scheme;
        proxy_set_header            Accept-Encoding "";
        proxy_set_header            Content-Type "";
        
        # Mask CFs involvement in upstream
        proxy_set_header            Cf-Connecting-Ip "";
        proxy_set_header            Cf-IpCountry "";
        proxy_set_header            Cf-Visitor "";
        proxy_set_header            CF-RAY "";
        proxy_set_header            Server "";
        
        # Hide CF Headers from response
        proxy_hide_header           CF-RAY;
        proxy_hide_header           Server;
        proxy_hide_header           Connection;
        
        proxy_connect_timeout       1;
        proxy_read_timeout          15;
        proxy_send_timeout          15;
        
        proxy_request_buffering     on;
        proxy_ignore_client_abort   on;
        
        # Safe to upstream all requests, as all requests are forced to be GET
        proxy_intercept_errors      on;
        proxy_next_upstream         non_idempotent error timeout invalid_header http_500 http_502 http_503 http_504 http_404;
        proxy_next_upstream_timeout 30;
        proxy_next_upstream_tries   2;
        
        proxy_method                GET;
        proxy_set_header            Host $subdomain$domain;
        proxy_pass                  http://$upstream;
        
        proxy_cookie_domain         ~^.*?$ .$domain;
        proxy_redirect              ~^((?:[^:]*:)?//[^:]+\.mediaclick[^.]+\.com)(?::\d+)?(/.+)$ https://$subdomain$domain$2;
    }
    
    # Log stats to datadog
    log_by_lua_block {
        local ngx_re            = require "ngx.re"
        local resty_dogstatsd   = require "resty_dogstatsd"
        
        local headers           = ngx.resp.get_headers()
        local internal_route    = ngx.re.match(ngx.var.uri, "^/(thisthingisnotathing|nginx|status(.php)?|fpm(-ping)?|v1)(/|$)")
        
        -- Methods are not required for logging (no errors, didn't go upstream)
        if (ngx.status < 300 or (ngx.status - 400) < 100) and internal_route then
            return
        end
        
        -- Async processing function
        local function post_process(premature, key, tags, response_time)
            -- Initialize
            local dogstatsd = resty_dogstatsd.new({
                statsd = {
                    host        = "127.0.0.1",
                    port        = 8125,
                    namespace   = "ngx"
                },
                tags = {}
            })
            
            -- Send metrics
            dogstatsd:increment(key .. ".count", 1, 1, tags)
            
            if response_time then
                dogstatsd:timer(key .. ".time", response_time, tags)
            end
        end
        
        -- Key reporting variables
        local args              = safe_url_args(ngx.req.get_uri_args() or {})
        local upstreams         = ngx_re.split(ngx.var.upstream_addr or ngx.var.server_addr, ", ") or {}
        local response_times    = ngx_re.split(ngx.var.upstream_header_time or ngx.var.request_time, ", ") or {}
        local upstream_statuses = ngx_re.split(ngx.var.upstream_status or ngx.status, ", ") or {}
        
        -- Shave/Scrub detection
        local scrub             = ngx.re.match(ngx.var.arg_referer or ngx.var.http_referer or "", "(?|&)y[0-9]=000([a-zA-Z])(&|$)") or nil
        -- Referer Host
        local referer_host      = ngx.re.match(ngx.var.arg_referer or ngx.var.http_referer or "", "^(?:[^:]*:)?(?://)?([^:/]+)") or nil
        
        local upstream_names    = { ["127.0.0.1:8001"] = "hydra", ["127.0.0.1:8002"] = "hp", ["127.0.0.1:8003"] = "ndp" }
        local safe_args         = { "sid", "rsid", "pub", "lpid", "retries", "redirects", "rel" }
        local na                = "N/A"
        
        for k,v in pairs(upstreams) do
            local response_time     = (tonumber(response_times[k]) or 0) * 1000
            local tags              = {
                "upstream:"         .. (upstream_names[v] or "internal"),
                "upstream_hops:"    .. (k or "1"),
                "response_code:"    .. (upstream_statuses[k] and upstream_statuses[k]:gsub("-", "499") or na),
                "vanity_domain:"    .. (ngx.var.domain or ngx.var.host or na),
                "subdomain:"        .. (ngx.var.subdomain:len() > 1 and ngx.var.subdomain or na),
                "origin:"           .. (ngx.var.arg_origin or (ngx.var.subdomain .. ngx.var.domain) or na),
                "referer:"          .. (referer_host and referer_host[1] or na),
                "uri:"              .. (ngx.var.uri or na),
                "http_accept:"      .. (headers["Accept"] or headers["accept"] or na),
                "scrub:"            .. (scrub and (scrub[1]:lower():match("y") and "active" or "inactive") or na)
            }
            
            -- pull arguments from the query string
            for k,v in pairs(safe_args) do
                table.insert(tags, v .. ':' .. (args[v] or na))
            end
            
            ngx.timer.at(0, post_process, "hydra.request", tags, response_time)
        end
    }
}

upstream hydra-hp {
    zone                                hydra-hp 64k;
    keepalive                           60;
    
    server                              127.0.0.1:8001 weight=999999999999 max_fails=0;
    server                              127.0.0.1:8002 backup max_fails=0;
    
    check                               interval=15000 rise=2 fall=2 timeout=10000 default_down=false type=http;
    check_http_send                     "GET /thisthingisnotathing HTTP/1.1\r\nHOST:www.mediaclicktrker.com\r\n\r\n";
    check_http_expect_alive             http_2xx;
}

upstream hp-ndp {
    zone                                hp-ndp 64k;
    keepalive                           60;
    
    server                              127.0.0.1:8002 weight=999999999999 max_fails=0;
    server                              127.0.0.1:8003 backup max_fails=0;
    
    check                               interval=15000 rise=2 fall=2 timeout=10000 default_down=false type=http;
    check_http_send                     "GET /thisthingisnotathing HTTP/1.1\r\nHOST:www.mediaclicktrker.com\r\n\r\n";
    check_http_expect_alive             http_2xx;
}

upstream hydra {
    zone                                hydra 64k;
    keepalive                           60;
    
    server                              127.0.0.1:8001 max_fails=0;
}

upstream hp {
    zone                                hp 64k;
    keepalive                           40;
    
    server                              127.0.0.1:8002 max_fails=0;
}

upstream ndp {
    zone                                ndp 64k;
    keepalive                           60;
    
    server                              127.0.0.1:8003 max_fails=0;
}

server {
    listen                              8001 default_server reuseport;
    
    more_set_headers                    "X-Backend-Server: hydra-$hostname";
    set                                 $upstream unix:/var/run/php5-fpm.sock;
    
    access_log                          /var/log/nginx/hydra.log main buffer=64k flush=30s if=$loggable;
    
    root                                <%= @path %>;
    try_files                           $uri/ /index.php?_url=$uri&$args;
    
    location = /nginx {
        allow                           127.0.0.1;
        deny                            all;
        
        access_log                      off;
        stub_status                     on;
    }
    
    location = /index.php {
        fastcgi_keep_conn               on;
        
        fastcgi_connect_timeout         10;
        fastcgi_read_timeout            15;
        fastcgi_send_timeout            15;
        fastcgi_request_buffering       on;
        fastcgi_ignore_client_abort     on;
        
        include                         fastcgi_params;
        fastcgi_index                   index.php;
        fastcgi_split_path_info         ^(.+\.php)(.*)$;
        fastcgi_param HTTP_HOST         $host;
        fastcgi_param PATH_INFO         $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED   $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME   $document_root$fastcgi_script_name;
        fastcgi_param REQUEST_SCHEME    $real_scheme;
        fastcgi_param HTTPS             $is_https if_not_empty;
        
        fastcgi_pass_request_headers    on;
        fastcgi_param REQUEST_METHOD    GET;
        fastcgi_pass                    $upstream;
    }
}

server {
    listen                              8002 default_server reuseport;
    
    more_set_headers                    "X-Backend-Server: hitpath";
    set                                 $upstream mediaclicklb.com;
    set                                 $domain www.mediaclicktrker.com;
    
    access_log                          /var/log/nginx/hp.log main buffer=64k flush=30s if=$loggable;
    
    location = /nginx {
        allow                           127.0.0.1;
        deny                            all;
        
        access_log                      off;
        stub_status                     on;
    }
    
    location ~* ^/rd/f {
        set                             $domain mediaclicklb.com;
        rewrite                         ^/rd/f(.*) /rd/r$1;
    }
    
    location / {
        proxy_http_version              1.1;
        proxy_set_header                Connection "";
        
        proxy_connect_timeout           10;
        proxy_read_timeout              15;
        proxy_send_timeout              15;
        proxy_request_buffering         on;
        
        # HP cant be trusted to wrap-up aborted connections
        proxy_ignore_client_abort       on;
        
        proxy_pass_request_headers      on;
        proxy_method                    GET;
        proxy_set_header                Host $domain;
        proxy_pass                      http://$upstream;
    }
}

server {
    listen                              8003 default_server reuseport;
    
    more_set_headers                    "X-Backend-Server: ndp-$hostname";
    set                                 $upstream unix:/var/run/php5-fpm.sock;
    
    access_log                          /var/log/nginx/ndp.log main buffer=64k flush=30s if=$loggable;
    
    root                                <%= @path %>;
    try_files                           $uri/ /index.php?_url=$uri&$args;
    
    location = /nginx {
        allow                           127.0.0.1;
        deny                            all;
        
        access_log                      off;
        stub_status                     on;
    }
    
    location = /index.php {
        fastcgi_keep_conn               on;
        
        fastcgi_connect_timeout         10;
        fastcgi_read_timeout            15;
        fastcgi_send_timeout            15;
        fastcgi_request_buffering       on;
        fastcgi_ignore_client_abort     on;
        
        include                         fastcgi_params;
        fastcgi_index                   index.php;
        fastcgi_split_path_info         ^(.+\.php)(.*)$;
        fastcgi_param HTTP_HOST         www.mediaclicktp.com;
        fastcgi_param PATH_INFO         $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED   $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME   $document_root$fastcgi_script_name;
        fastcgi_param REQUEST_SCHEME    $real_scheme;
        fastcgi_param HTTPS             $is_https if_not_empty;
        
        fastcgi_pass_request_headers    on;
        fastcgi_param REQUEST_METHOD    GET;
        fastcgi_pass                    $upstream;
    }
}

server {
    listen                              80;
    listen                              [::]:80;

    server_name                         mediaclicktp.com www.mediaclicktp.com *.mediaclicktp.com
                                        mediaclicklb.com www.mediaclicklb.com *.mediaclicklb.com
                                        mediaclickndp.com www.mediaclickndp.com *.mediaclickndp.com;
    
    set                                 $upstream hp-ndp;
    set_by_lua_block $upstream {
        local args  = safe_url_args(ngx.req.get_uri_args() or {})
        args["sid"] = tonumber(args["sid"] or args["progid"])
        args["hid"] = tonumber(args["hid"] or (args["sid"] ~= nil and ngx.var["cookie_uid" .. args["sid"]]:match("^(%d+)-")))

        -- if hit id is below the range of hp upstream, handle via ndp
        if (args["hid"] ~= nil and tonumber(args["hid"]) < 900000000) or ngx.var.host:match("mediaclickndp") then
            return "ndp"
        elseif ngx.var.host:match("mediaclicklb") then
            return "hp"
        else
            return "hp-ndp"
        end
    }
    
    access_log                          /var/log/nginx/hp-ndp.log main buffer=64k flush=30s if=$loggable;
    
    more_set_headers                    'Server: TP';
    
    location = /nginx {
        allow                           127.0.0.1;
        deny                            all;
        
        access_log                      off;
        stub_status                     on;
    }
    
    location / {
        proxy_http_version              1.1;
        
        proxy_connect_timeout           1;
        proxy_read_timeout              15;
        proxy_send_timeout              15;
        proxy_request_buffering         on;
        proxy_ignore_client_abort       on;
        
        proxy_intercept_errors          on;
        proxy_next_upstream             non_idempotent error timeout invalid_header http_500 http_502 http_503 http_504 http_404;
        proxy_next_upstream_timeout     30;
        proxy_next_upstream_tries       2;

        proxy_pass_request_headers      on;
        proxy_method                    GET;
        proxy_pass                      http://$upstream;

        proxy_cookie_domain             ~^.*?$ .mediaclicktp.com;
        proxy_redirect                  ~^((?:[^:]*:)?//[^:]+\.mediaclick[^.]+\.com)(?::\d+)?(/.+)$ $2;
    }
}
